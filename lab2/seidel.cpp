#include <iostream>  // Подключаем библиотеку для ввода/вывода (cout, cerr)
#include <vector>    // Подключаем библиотеку для работы с динамическими массивами (vector)
#include <cmath>     // Подключаем библиотеку для математических функций (abs - модуль числа)
#include <iomanip>   // Подключаем библиотеку для форматированного вывода (setprecision - задание точности)

using namespace std;  // Используем пространство имен std, чтобы не писать std:: перед объектами (cout, vector и т.д.)

// Функция, реализующая метод Зейделя для решения системы линейных уравнений
vector<double> seidel(const vector<vector<double>>& A, const vector<double>& b, const vector<double>& initialGuess, double tolerance = 0.01, int maxIterations = 1000) {
    // const vector<vector<double>>& A: константная ссылка на матрицу коэффициентов (передаем константную ссылку, чтобы не копировать матрицу и не изменять ее)
    // const vector<double>& b: константная ссылка на вектор свободных членов
    // const vector<double>& initialGuess: константная ссылка на начальное приближение
    // double tolerance = 0.01: желаемая точность решения (по умолчанию 0.01)
    // int maxIterations = 1000: максимальное количество итераций (по умолчанию 1000)

    int n = A.size(); // Определяем размерность системы (количество уравнений или неизвестных)

    // Check for diagonal dominance - Проверяем условие диагонального преобладания
    for (int i = 0; i < n; ++i) { // Перебираем строки матрицы
        double diagonal = abs(A[i][i]); // Вычисляем модуль диагонального элемента
        double sum = 0.0; // Инициализируем сумму модулей недиагональных элементов
        for (int j = 0; j < n; ++j) { // Перебираем элементы в строке
            if (i != j) { // Исключаем диагональный элемент
                sum += abs(A[i][j]); // Добавляем модуль недиагонального элемента к сумме
            }
        }
        if (diagonal <= sum) { // Если модуль диагонального элемента меньше или равен сумме модулей недиагональных элементов
            cout << "Matrix is not diagonally dominant.  Seidel method may not converge." << endl; // Выводим предупреждение
            return vector<double>(n, NAN);  // Return NaN to indicate failure - Возвращаем вектор, заполненный NaN, чтобы указать на неудачу
        }
    }

    vector<double> x = initialGuess; // Создаем вектор x для хранения текущего приближения решения и инициализируем его начальным приближением
    vector<double> x_new(n); // Создаем вектор x_new для хранения нового приближения решения на текущей итерации
    double error; // Объявляем переменную error для хранения ошибки (расхождения между текущим и предыдущим приближениями)

    // Основной цикл метода Зейделя: выполняем итерации до достижения заданной точности или превышения максимального количества итераций
    for (int iteration = 0; iteration < maxIterations; ++iteration) {
        error = 0.0; // Сбрасываем значение ошибки на начало каждой итерации
        // Цикл по всем уравнениям системы
        for (int i = 0; i < n; ++i) {
            double sum1 = 0.0; // Инициализируем сумму для членов, использующих (k+1)-е приближение для j < i
            double sum2 = 0.0; // Инициализируем сумму для членов, использующих k-е приближение для j >= i

            // Вычисляем суммы, необходимые для нахождения нового значения x[i]
            // Учитываем, что мы также делим A[i][j] и b[i] на A[i][i] для масштабирования уравнений
            for (int j = 0; j < i; ++j) {
                sum1 += (A[i][j]/A[i][i]) * x_new[j]; // Используем уже обновленные значения x_new[j] с текущей итерации для j < i
            }

            for (int j = i+1; j < n; ++j) {
                sum2 += (A[i][j]/A[i][i]) * x[j]; // Используем значения с предыдущей итерации x[j] для j > i (а также делим на A[i][i] как часть масштабирования)
            }

            x_new[i] = ((b[i]/A[i][i]) - sum1 - sum2); // Вычисляем новое значение x_i^(k+1), применяя масштабирование к b[i]
            error += abs(x_new[i] - x[i]); // Накапливаем ошибку (абсолютную разницу между новым и старым значениями x[i])
        }

        // Копируем новые значения из x_new в x для использования на следующей итерации
        for(int i = 0; i < n; ++i){
          x[i] = x_new[i]; // Обновляем значения x[i] новыми значениями x_new[i]
        }

        // Проверяем условие сходимости: если ошибка меньше заданной точности, то решение найдено
        if (error < tolerance) {
            cout << "Converged in " << iteration + 1 << " iterations." << endl; // Выводим сообщение о сходимости и количестве итераций
            return x; // Возвращаем найденное решение
        }
    }

    // Если метод не сошелся за maxIterations итераций
    cout << "Seidel method did not converge within " << maxIterations << " iterations." << endl; // Выводим сообщение о том, что метод не сошелся
    return x; // Возвращаем последнее приближение (даже если оно не удовлетворяет заданной точности)
}

int main() {
    // Пример использования метода Зейделя
    // Задаем матрицу коэффициентов A
    vector<vector<double>> A = {
        {3, 1, -1},
        {2, 4, 1},
        {10, -1, 3}
    };

    // Задаем вектор свободных членов b
    vector<double> b = {6, 9, 4};

    // Задаем начальное приближение для решения
    vector<double> initialGuess = {0, 0, 0};

    // Вызываем функцию seidel для решения системы уравнений
    vector<double> solution = seidel(A, b, initialGuess, 0.01, 1000);

    // Проверяем, не вернула ли функция NaN (указание на неудачу)
    if (isnan(solution[0])) { // Проверяем, является ли первый элемент вектора solution NaN
        cout << "Method failed due to non-diagonally dominant matrix." << endl; // Выводим сообщение о том, что метод не сошелся из-за отсутствия диагонального преобладания
    } else {
        // Выводим найденное решение
        cout << "Solution:" << endl;
        for (int i = 0; i < solution.size(); ++i) {
            cout << "x_" << i + 1 << " = " << fixed << setprecision(6) << solution[i] << endl; // Выводим каждый элемент решения с точностью 6 знаков после запятой
        }
    }

    return 0; // Завершаем программу
}