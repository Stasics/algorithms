#include <iostream> // Подключаем библиотеку для ввода/вывода
#include <cmath>   // Подключаем библиотеку математических функций (pow, sin, sqrt)
#include <cstdlib> // Подключаем библиотеку для работы с генератором случайных чисел (rand, srand)
#include <ctime>   // Подключаем библиотеку для получения текущего времени (time), используется для инициализации генератора случайных чисел

using namespace std; // Используем пространство имен std, чтобы не писать std:: перед каждым cout, cin и т.д.

// Определяемая функция (пример)
// Эта функция, интеграл которой мы будем вычислять методом Монте-Карло.
double f(double x) {
    // Функция 1/(1 - 0.49 * sin^2(x)).  Обратите внимание на возможность деления на ноль.
    return  1/(1 - 0.49 * pow(sin(x), 2));
}

// Метод Монте-Карло для вычисления интеграла
double MonteCarlo(double a, double b, int n) {
    // a - нижний предел интегрирования
    // b - верхний предел интегрирования
    // n - количество случайных точек (проб)

    double max_f = 0.0;      // Максимальное значение функции на интервале [a, b]
    double min_f = 0.0;      // Минимальное значение функции на интервале [a, b]
    double height;           // Высота прямоугольника

    // Оценка максимума и минимума функции
    // Чтобы корректно оценить интеграл, нужно знать максимум и минимум функции на отрезке.
    // Здесь мы делаем приближенную оценку, генерируя 1000 случайных точек на интервале [a, b].
    for (int i = 0; i < 1000; ++i) {
        double x = a + (double)rand() / RAND_MAX * (b - a); // Генерируем случайное x на интервале [a, b]
        max_f = max(max_f, f(x));                          // Обновляем max_f, если f(x) больше текущего значения
        min_f = min(min_f, f(x));                          // Обновляем min_f, если f(x) меньше текущего значения
    }

    height = max_f - min_f; // Вычисляем высоту прямоугольника, охватывающего график функции

    int hits_positive = 0;   // Количество "попаданий" выше оси X (т.е. точек, лежащих под графиком функции и выше оси X)
    int hits_negative = 0;   // Количество "попаданий" ниже оси X (т.е. точек, лежащих над графиком функции и ниже оси X)
    double x, y;             // Координаты случайной точки

    // Генерируем случайные точки и считаем "попадания"
    for (int i = 0; i < n; ++i) {
        x = a + (double)rand() / RAND_MAX * (b - a); // Генерируем случайное x на интервале [a, b]
        y = min_f + (double)rand() / RAND_MAX * height; // Генерируем случайное y на интервале [min_f, max_f]

        // Проверяем, попала ли точка (x, y) под график функции f(x)
        if (y <= f(x)) {
            // Если точка попала под график, определяем, находится ли она выше или ниже оси X
            if (y >= 0) {
                hits_positive++; // Увеличиваем счетчик "попаданий" выше оси X
            } else {
                hits_negative++; // Увеличиваем счетчик "попаданий" ниже оси X
            }
        }
    }

    // Вычисляем площадь прямоугольника и приближенное значение интеграла
    double area = (b - a) * height;               // Площадь прямоугольника, охватывающего график функции
    double positive_area = area * (double)hits_positive / n; // Приближенная площадь под графиком функции выше оси X
    double negative_area = area * (double)hits_negative / n; // Приближенная площадь над графиком функции ниже оси X

    double integral = positive_area - negative_area; // Вычисляем приближенное значение интеграла как разность площадей
    return integral;                             // Возвращаем приближенное значение интеграла
}

int main() {
    // Инициализация генератора случайных чисел
    // srand(time(0)) инициализирует генератор случайных чисел текущим временем.
    // Это обеспечивает, что при каждом запуске программы будет генерироваться новая последовательность случайных чисел.
    srand(time(0));

    double a, b;          // Пределы интегрирования
    double n;             // Количество случайных точек (проб)
    int k;               // Количество итераций метода Монте-Карло

    a = 0.0;             // Нижний предел интегрирования
    b = 5.0;             // Верхний предел интегрирования

    cout << "(k): ";      // Выводим запрос на ввод количества итераций
    cin >> k;              // Считываем количество итераций с клавиатуры

    cout << "(n): ";      // Выводим запрос на ввод количества точек
    cin >> n;              // Считываем количество точек с клавиатуры

    double sum_s = 0.0;          // Сумма значений интеграла по всем итерациям
    double sum_s_squared = 0.0;    // Сумма квадратов значений интеграла по всем итерациям

    // Выполняем k итераций
    for (int i = 0; i < k; ++i) {
        
        double current_integral = MonteCarlo(a, b, n); // Вычисляем интеграл методом Монте-Карло

        // Обновляем суммы
        sum_s += current_integral;                   // Суммируем значения интеграла
        sum_s_squared += current_integral * current_integral; // Суммируем квадраты значений интеграла

        cout << i + 1 << ": integral = " << current_integral << endl; // Выводим результат каждой итерации
    }

    double average_integral = sum_s / k;           // Вычисляем среднее значение интеграла
    double average_squared = sum_s_squared / k;

    double standard_deviation = sqrt(average_squared - average_integral * average_integral); // Оцениваем стандартное отклонение

    cout << "integral: " << average_integral << endl; // Выводим среднее значение интеграла
    cout << "dev: " << standard_deviation << endl;    // Выводим стандартное отклонение

    return 0; // Возвращаем 0, что означает успешное завершение программы
}